This is a variant of a [well-known "Covering Segments by Points" problem](https://medium.com/competitive/covering-segments-by-points-fc2c56c4b038). In that problem, you simply sort intervals by their endpoint and then loop through the intervals while maintaining a set of points `S`. During the loop, if you encounter an interval which contains no point in `S`, then you add the endpoint of that interval to `S`.

However, we now have the restriction that the set `S` of points must be a `K`-set. How does this change our solution? When we encounter an interval which contains no point in `S`, we first check, is the endpoint of that interval within `K` of the maximum element of `S`? If so, we can add the endpoint of the interval to `S`. If not, then adding the endpoint of the interval to `S` will violate the `K`-set requirement, so we instead add the maximum element of `S` plus `K` to `S`. We then keep repeating this check until some point to `S` is added which is contained within the interval.

However, if we were to solve the problem using this method of repeating this check, we would get time limit exceeded because we are adding points one-by-one. If `K` is very small, like `K=1`, and two intervals are very far apart, like `[-1000000000, -999999999]` and `[999999999, 1000000000]`, we may require up to `2 * 10^9` points to be in our `K`-set, which is too many operations to add points to our set one-by-one.

Instead, if `M` is the maximum element in our `K`-set `S` so far, then by following the logic of the repeating check method, we can find that if an interval `[B, E]` contains no point in `S`, we need to add `ceil((B-M)/K)` points to our `K`-set in order to be able to add a point in the interval `[B, E]` without violating the `K`-set requirement. Then, we simply need to calculate the new maximum element in our `K`-set `S`: Either the last element we add to the set is the endpoint of the interval `E` or the previous maximum `M` plus `K` times the number of points we added. Therefore, we take the minimum of `E` and `M+K*ceil((B-M)/K)` to get the new maximum of `S`.